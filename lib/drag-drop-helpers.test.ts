import { describe, it, expect, beforeAll } from "vitest";
import { Job, JobStatus } from "@prisma/client";
import {
  isColumnId,
  getSortedJobsForStatus,
  calculateDropResult,
  JOB_STATUSES,
} from "./drag-drop-helpers";
import { calculateOrderBetween, calculateOrderAtEnd } from "./fractional-index";

// Generate valid fractional index keys for testing
// These need to be generated by the library to be valid
let ORDER_A: string;
let ORDER_B: string;
let ORDER_C: string;
let ORDER_D: string;

beforeAll(() => {
  // Generate sequential valid order keys
  ORDER_A = calculateOrderBetween(null, null);
  ORDER_B = calculateOrderAtEnd(ORDER_A);
  ORDER_C = calculateOrderAtEnd(ORDER_B);
  ORDER_D = calculateOrderAtEnd(ORDER_C);
});

// Helper to create mock jobs
function createMockJob(
  id: number,
  status: JobStatus,
  order: string,
  createdAt: Date = new Date()
): Job {
  return {
    id,
    userId: "user-1",
    company: `Company ${id}`,
    title: `Title ${id}`,
    location: null,
    jobPostingUrl: null,
    jobPostingText: null,
    status,
    notes: null,
    contactPerson: null,
    resumeUrl: null,
    coverLetterUrl: null,
    dateApplied: null,
    deletedAt: null,
    order,
    createdAt,
    updatedAt: new Date(),
  };
}

describe("drag-drop-helpers", () => {
  describe("isColumnId", () => {
    it("returns true for valid JobStatus values", () => {
      JOB_STATUSES.forEach((status) => {
        expect(isColumnId(status)).toBe(true);
      });
    });

    it("returns false for numeric job ids", () => {
      expect(isColumnId(123)).toBe(false);
      expect(isColumnId(1)).toBe(false);
    });

    it("returns false for string job ids", () => {
      expect(isColumnId("123")).toBe(false);
      expect(isColumnId("job-1")).toBe(false);
    });
  });

  describe("getSortedJobsForStatus", () => {
    it("filters jobs by status", () => {
      const jobs = [
        createMockJob(1, "WISHLIST", ORDER_A),
        createMockJob(2, "APPLIED", ORDER_A),
        createMockJob(3, "WISHLIST", ORDER_B),
      ];

      const wishlistJobs = getSortedJobsForStatus("WISHLIST", jobs);

      expect(wishlistJobs).toHaveLength(2);
      expect(wishlistJobs.map((j) => j.id)).toEqual([1, 3]);
    });

    it("sorts by order ascending", () => {
      const jobs = [
        createMockJob(1, "WISHLIST", ORDER_C),
        createMockJob(2, "WISHLIST", ORDER_A),
        createMockJob(3, "WISHLIST", ORDER_B),
      ];

      const sorted = getSortedJobsForStatus("WISHLIST", jobs);

      expect(sorted.map((j) => j.id)).toEqual([2, 3, 1]);
    });

    it("uses createdAt desc as tie-breaker when orders are equal", () => {
      const older = new Date("2024-01-01");
      const newer = new Date("2024-06-01");

      const jobs = [
        createMockJob(1, "WISHLIST", ORDER_A, older),
        createMockJob(2, "WISHLIST", ORDER_A, newer),
      ];

      const sorted = getSortedJobsForStatus("WISHLIST", jobs);

      // Newer job should come first when orders are equal
      expect(sorted.map((j) => j.id)).toEqual([2, 1]);
    });

    it("returns empty array when no jobs match status", () => {
      const jobs = [createMockJob(1, "WISHLIST", ORDER_A)];

      const appliedJobs = getSortedJobsForStatus("APPLIED", jobs);

      expect(appliedJobs).toEqual([]);
    });
  });

  describe("calculateDropResult", () => {
    describe("dropping on a column", () => {
      it("drops at end of empty column", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [createMockJob(1, "WISHLIST", ORDER_A)];

        const result = calculateDropResult(job, "APPLIED", jobs);

        expect(result).not.toBeNull();
        expect(result!.targetStatus).toBe("APPLIED");
        expect(result!.statusChanged).toBe(true);
        // Order should be a valid fractional index
        expect(result!.newOrder).toBeTruthy();
      });

      it("drops at end of populated column", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [
          createMockJob(1, "WISHLIST", ORDER_A),
          createMockJob(2, "APPLIED", ORDER_B),
          createMockJob(3, "APPLIED", ORDER_C),
        ];

        const result = calculateDropResult(job, "APPLIED", jobs);

        expect(result!.targetStatus).toBe("APPLIED");
        expect(result!.statusChanged).toBe(true);
        // New order should be after ORDER_C
        expect(result!.newOrder > ORDER_C).toBe(true);
      });
    });

    describe("dropping on a card", () => {
      it("drops at position of target card (inserting before it)", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_D };
        const jobs = [
          createMockJob(1, "WISHLIST", ORDER_D),
          createMockJob(2, "APPLIED", ORDER_A),
          createMockJob(3, "APPLIED", ORDER_C),
        ];

        // Drop on job 3 (second card in APPLIED)
        const result = calculateDropResult(job, 3, jobs);

        expect(result!.targetStatus).toBe("APPLIED");
        // New order should be between ORDER_A and ORDER_C
        expect(result!.newOrder > ORDER_A).toBe(true);
        expect(result!.newOrder < ORDER_C).toBe(true);
      });

      it("drops at start when dropping on first card", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_D };
        const jobs = [
          createMockJob(1, "WISHLIST", ORDER_D),
          createMockJob(2, "APPLIED", ORDER_B),
          createMockJob(3, "APPLIED", ORDER_C),
        ];

        // Drop on job 2 (first card in APPLIED)
        const result = calculateDropResult(job, 2, jobs);

        expect(result!.targetStatus).toBe("APPLIED");
        // New order should be before ORDER_B
        expect(result!.newOrder < ORDER_B).toBe(true);
      });

      it("returns null when target card not found", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [createMockJob(1, "WISHLIST", ORDER_A)];

        const result = calculateDropResult(job, 999, jobs);

        expect(result).toBeNull();
      });
    });

    describe("edge cases", () => {
      it("handles jobs with same order value", () => {
        // When jobs have the same order, we can't calculate between them
        // The code should handle this by inserting before the target
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [
          createMockJob(1, "WISHLIST", ORDER_A),
          createMockJob(2, "APPLIED", ORDER_A), // Same order as job 3
          createMockJob(3, "APPLIED", ORDER_A), // Same order as job 2
        ];

        // Drop on job 3 (between two jobs with same order)
        const result = calculateDropResult(job, 3, jobs);

        expect(result).not.toBeNull();
        expect(result!.targetStatus).toBe("APPLIED");
        // Should not throw, should return a valid order
        expect(result!.newOrder).toBeTruthy();
        // New order should be before ORDER_A (since we can't insert between equal values)
        expect(result!.newOrder < ORDER_A).toBe(true);
      });

      it("detects no change when status and order remain same", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [
          createMockJob(1, "WISHLIST", ORDER_A),
          createMockJob(2, "WISHLIST", ORDER_B),
        ];

        // Drop on first card (same position)
        const result = calculateDropResult(job, 1, jobs);

        expect(result!.statusChanged).toBe(false);
        // Note: order will change to be "before" the first remaining item (ORDER_B)
      });

      it("detects status change when moving between columns", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [createMockJob(1, "WISHLIST", ORDER_A)];

        const result = calculateDropResult(job, "APPLIED", jobs);

        expect(result!.statusChanged).toBe(true);
      });

      it("handles reordering within same column", () => {
        const job = { id: 1, status: "WISHLIST" as JobStatus, order: ORDER_A };
        const jobs = [
          createMockJob(1, "WISHLIST", ORDER_A),
          createMockJob(2, "WISHLIST", ORDER_B),
          createMockJob(3, "WISHLIST", ORDER_C),
        ];

        // Drop on job 3 (move from position 1 to position 3)
        const result = calculateDropResult(job, 3, jobs);

        expect(result!.targetStatus).toBe("WISHLIST");
        expect(result!.statusChanged).toBe(false);
        expect(result!.orderChanged).toBe(true);
        // New order should be between ORDER_B and ORDER_C
        expect(result!.newOrder > ORDER_B).toBe(true);
        expect(result!.newOrder < ORDER_C).toBe(true);
      });
    });
  });
});
